/*
 * Copyright (C) 2012 Tim Vaughan <tgvaughan@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package master.outputs;

import beast.core.Description;
import java.io.FileNotFoundException;
import master.InheritanceEnsemble;
import master.model.Node;
import java.io.PrintStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import master.InheritanceTrajectory;

/**
 * Class containing static methods useful for exporting tree-like graphs
 * using the NEXUS format.  An advantage of this format over the vanilla
 * Newick format is that it allows annotations describing the population
 * type and location of each node.
 * 
 * <p>Note that extended newick strings will be used if the graph is not
 * tree-like in the direction it's traversed.</p>
 *
 * @author Tim Vaughan <tgvaughan@gmail.com>
 */
@Description("Output writer capable of writing inheritance graph to"
        + " disk in NEXUS format.  Note that in the case that the graph is"
        + " not tree-like, an annotated variant of the extended Newick format"
        + " of Cardona et al, BMC Bioinf. (2008) is used in place of the"
        + " traditional annotated Newick for the topology strings.")
public class NexusOutput extends NewickOutput {
    
    public NexusOutput() { }
    
    @Override
    public void initAndValidate() { }
    
    @Override
    public void write(InheritanceTrajectory itraj) {
        
        PrintStream pstream = null;
        try {
            pstream = new PrintStream(fileNameInput.get());
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NexusOutput.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        if (itraj.getSpec().getVerbosity()>0)
            System.out.println("Writing NEXUS output...");
        
        pstream.println("#nexus\n\nBegin trees;");
        
        // Skip empty inheritance graphs:
        if (!itraj.getStartNodes().isEmpty()) {
            pstream.print("tree TREE = ");
            generateOutput(itraj, reverseTime, collapseSingleChildNodes, pstream);
        } else {
            if (itraj.getSpec().getVerbosity()>0)
                System.out.println("Warning: NEXUS writer skipping empty graph.");
        }
        
        pstream.println("End;");
    }

    @Override
    public void write(InheritanceEnsemble iensemble) {
        
        PrintStream pstream = null;
        try {
            pstream = new PrintStream(fileNameInput.get());
        } catch (FileNotFoundException ex) {
            Logger.getLogger(NexusOutput.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        if (iensemble.getSpec().getVerbosity()>0)
            System.out.println("Writing NEXUS output...");
                
        pstream.println("#nexus\n\nBegin trees;");
        
        int skips = 0;
        for (int i=0; i<iensemble.getTrajectories().size(); i++) {
            InheritanceTrajectory thisTraj = iensemble.getTrajectories().get(i);
            
            // Skip empty inheritance graphs:
            if (!thisTraj.getStartNodes().isEmpty()) {
                pstream.print("tree TREE_" + i + " = ");
                generateOutput(thisTraj, reverseTime, collapseSingleChildNodes, pstream);
            } else {
                skips += 1;
                if (iensemble.getSpec().getVerbosity()>0)
                    System.out.print("\rWarning: NEXUS writer skipping empty "
                            + "graph. (repeated " + skips + " times)");
            }
        }
        pstream.println("End;");
        
        if (iensemble.getSpec().getVerbosity()>0 && skips>0)
            System.out.println();
    }

    @Override
    protected void addLabel(Node node, double branchLength) {
        
        if (leafLabels.containsKey(node))
            ps.append(leafLabels.get(node));
        
        if (hybridIDs.containsKey(node))
            ps.append("#").append(String.valueOf(hybridIDs.get(node)));
        // note that we've omitted the optional "type" specifier
        
        // Annotations traditionally refer to the branch _above_ the node
        // on the tree.  The following correction ensures this tradition is
        // followed when a tree is generated by reading a graph in reverse.
        Node branchNode;
        if (reverseTime) {
            branchNode = node.getChildren().get(0);
        } else
            branchNode = node;
        

        ps.append("[&");
        ps.format("type=\"%s\"", branchNode.getPopulation().getType().getName());
        if (!branchNode.getPopulation().isScalar()) {
            ps.append(",location=\"");

            int[] loc = branchNode.getPopulation().getLocation();
            for (int i=0; i<loc.length; i++) {
                if (i>0)
                    ps.append(" ");
                ps.append(String.valueOf(loc[i]));
            }
            
            ps.append("\"");
        }
        if (node.getReaction() != null && node.getReaction().getName() != null)
            ps.format(",reaction=\"%s\"", node.getReaction().getName());
        ps.append(",time=").append(String.valueOf(node.getTime()));
        
        // Add general annotations:
        if (node.getAttributeNames() != null) {
            for (String name : node.getAttributeNames()) {
                Object value = node.getAttribute(name);
                
                if (value instanceof Integer) {
                    ps.append("," + name + "=" + String.valueOf((Integer)value));
                    continue;
                }
                
                if (value instanceof Double) {
                    ps.append("," + name + "=" + String.valueOf((Double)value));
                    continue;
                }
                                
                if (value instanceof Boolean) {
                    ps.append("," + name + "=" + String.valueOf((Boolean)value));
                    continue;
                }
                                
                if (value instanceof String) {
                    ps.append("," + name + "=" + (String)value);
                    continue;
                }
            }
        }
        
        ps.append("]");
        
        ps.append(":").append(String.valueOf(branchLength));
    }
}
